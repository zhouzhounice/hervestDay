## 基本概念

- 数据结构：一组数据的存储结构
- 算法：操作数据的一组方法

## 学习重点

- 数据结构：
  - 数组
  - 链表
  - 栈
  - 队列
  - 散列表
  - 二叉树
  - 堆
  - 跳表
  - 图
  - Trie
  - 树
- 算法：
  - 递归
  - 排序
  - 二分查找
  - 搜索
  - 哈希算法
  - 贪心算法
  - 分治算法
  - 回溯算法
  - 动态规划
  - 字符串匹配算法

## 复杂度分析

常见的时间复杂度（递增）

- 常量阶：O(1)
- 对数阶：O(logn)
- 线性阶：O(n)
- 线性对数阶：O(nlogn)
- 平方阶：O(n^2)
- 立方阶：O(n^3)
- k次方阶：O(n^k)
- 指数阶：O(2^n)  --非多项式量级
- 阶乘阶：O(!n)  --非多项式量级

把非多项式量级的问题称为__NP(non-deterministic polynomial)__问题

### O(1)

```c
int i = 8;
int j = 6;
int sum = i + j;
```

### O(logn)、O(nlogn)

```c
i = 1
    while(i <= n){
        i = i * 2;
    }
```

### O(m+n)、O(m*n)

```c

int cal(int m, int n) {
  int sum_1 = 0;
  int i = 1;
  for (; i < m; ++i) {
    sum_1 = sum_1 + i;
  }

  int sum_2 = 0;
  int j = 1;
  for (; j < n; ++j) {
    sum_2 = sum_2 + j;
  }

  return sum_1 + sum_2;
}
```

## 进阶时间复杂度分析

```c
// 查找数组array中 有无x 如果有则返回下标 如果没有则返回-1
int find(int[] array, int n, int x){
    int i = 0;
    int pos = -1;
    for(;i<n;++i){
        if(array[i] == x) pos = i;
    }
    return pos;
}
// 以上代码，在数组的任何位置查找到x的时间复杂度都为O(n) 对于以上代码做出优化
int find(int[] array, int n, int x){
    int i = 0;
    int pos = -1;
    for(;i<n;++i){
        if(array[i]==x){
            pos = i;
            breack;
        }
    }
    return pos;
}
```

改进后的代码，如果要查找的数恰好在数组第一位，则时间复杂度为O(1)，如果要查找的数恰好在末尾，则时间复杂度为O(n);

### 最好情况时间复杂度

在最理想的情况下执行这段代码的时间复杂度

### 最坏情况时间复杂度

在最糟糕的情况下执行这段代码的时间复杂度

### 平均时间复杂度(加权平均复杂度/期望平均复杂度)

将各种情况的复杂度一起算进去后的复杂度：

在上述例子中，查找某一个元素有找到某个元素和未找到某个元素两种情况，而在各个位置找到某个元素的概率相等。所以计算它们的加权平均值：

`1*1/2n + ... + n*1/2n + n*1/2 = (3n+1)/4`

则加权平均时间为O(n)

### 均摊时间复杂度(摊还分析/平摊分析)

## 数组

如何实现数组随机访问？

低效的“插入“和”删除“操作

数组的访问越界问题

容器可以完全替代数组吗

数组的下标为什么要从0开始

## 链表

## 栈

## 队列

## 递归

## 排序

### 线性排序

### 排序优化

## 查找

### 二分查找

## 跳表

## 散列表

## 哈希算法

## 树

### 二叉树

### 红黑树

### 递归树

## 堆和堆排序

## 堆的应用

## 图的表示

## 深度优先和广度优先

## 字符串匹配基础

## Trie树

## AC自动机

## 贪心算法

## 分治算法

## 动态规划

